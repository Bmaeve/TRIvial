{"version":3,"file":"text-iterators.js","names":["makeTextDecoderIterator","arrayBufferIterator","options","textDecoder","TextDecoder","undefined","arrayBuffer","decode","stream","makeTextEncoderIterator","textIterator","textEncoder","TextEncoder","text","encode","makeLineIterator","previous","textChunk","eolIndex","indexOf","line","slice","length","makeNumberedLineIterator","lineIterator","counter"],"sources":["../../../../src/lib/iterators/text-iterators.ts"],"sourcesContent":["// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\nexport async function* makeTextDecoderIterator(\n  arrayBufferIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options: TextDecoderOptions = {}\n): AsyncIterable<string> {\n  const textDecoder = new TextDecoder(undefined, options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* makeTextEncoderIterator(\n  textIterator: AsyncIterable<string> | Iterable<ArrayBuffer>\n): AsyncIterable<ArrayBuffer> {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\n\nexport async function* makeLineIterator(\n  textIterator: AsyncIterable<string>\n): AsyncIterable<string> {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(\n  lineIterator: AsyncIterable<string>\n): AsyncIterable<{counter: number; line: string}> {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n"],"mappings":";;AAGA,OAAO,gBAAgBA,uBAAuB,CAC5CC,mBAAuE,EAEhD;EAAA,IADvBC,OAA2B,uEAAG,CAAC,CAAC;EAEhC,MAAMC,WAAW,GAAG,IAAIC,WAAW,CAACC,SAAS,EAAEH,OAAO,CAAC;EACvD,WAAW,MAAMI,WAAW,IAAIL,mBAAmB,EAAE;IACnD,MAAM,OAAOK,WAAW,KAAK,QAAQ,GACjCA,WAAW,GACXH,WAAW,CAACI,MAAM,CAACD,WAAW,EAAE;MAACE,MAAM,EAAE;IAAI,CAAC,CAAC;EACrD;AACF;;AAOA,OAAO,gBAAgBC,uBAAuB,CAC5CC,YAA2D,EAC/B;EAC5B,MAAMC,WAAW,GAAG,IAAIC,WAAW,EAAE;EACrC,WAAW,MAAMC,IAAI,IAAIH,YAAY,EAAE;IACrC,MAAM,OAAOG,IAAI,KAAK,QAAQ,GAAGF,WAAW,CAACG,MAAM,CAACD,IAAI,CAAC,GAAGA,IAAI;EAClE;AACF;;AAQA,OAAO,gBAAgBE,gBAAgB,CACrCL,YAAmC,EACZ;EACvB,IAAIM,QAAQ,GAAG,EAAE;EACjB,WAAW,MAAMC,SAAS,IAAIP,YAAY,EAAE;IAC1CM,QAAQ,IAAIC,SAAS;IACrB,IAAIC,QAAQ;IACZ,OAAO,CAACA,QAAQ,GAAGF,QAAQ,CAACG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;MAE/C,MAAMC,IAAI,GAAGJ,QAAQ,CAACK,KAAK,CAAC,CAAC,EAAEH,QAAQ,GAAG,CAAC,CAAC;MAC5CF,QAAQ,GAAGA,QAAQ,CAACK,KAAK,CAACH,QAAQ,GAAG,CAAC,CAAC;MACvC,MAAME,IAAI;IACZ;EACF;EAEA,IAAIJ,QAAQ,CAACM,MAAM,GAAG,CAAC,EAAE;IACvB,MAAMN,QAAQ;EAChB;AACF;;AAQA,OAAO,gBAAgBO,wBAAwB,CAC7CC,YAAmC,EACa;EAChD,IAAIC,OAAO,GAAG,CAAC;EACf,WAAW,MAAML,IAAI,IAAII,YAAY,EAAE;IACrC,MAAM;MAACC,OAAO;MAAEL;IAAI,CAAC;IACrBK,OAAO,EAAE;EACX;AACF"}