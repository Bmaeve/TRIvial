"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeMetadataFromLasHeader = exports.getLASSchema = void 0;
const schema_1 = require("@loaders.gl/schema");
/**
 * Gets schema from PLY header
 * @param lasHeader
 * @param metadata
 * @returns Schema
 */
function getLASSchema(lasHeader, attributes) {
    const metadataMap = makeMetadataFromLasHeader(lasHeader);
    const schema = (0, schema_1.deduceMeshSchema)(attributes, metadataMap);
    return schema;
}
exports.getLASSchema = getLASSchema;
/**
 * Make arrow like schema metadata by LASHeader properties
 * @param lasHeader
 * @returns
 */
function makeMetadataFromLasHeader(lasHeader) {
    const metadataMap = new Map();
    metadataMap.set('las_pointsOffset', lasHeader.pointsOffset.toString(10));
    metadataMap.set('las_pointsFormatId', lasHeader.pointsFormatId.toString(10));
    metadataMap.set('las_pointsStructSize', lasHeader.pointsStructSize.toString(10));
    metadataMap.set('las_pointsCount', lasHeader.pointsCount.toString(10));
    metadataMap.set('las_scale', JSON.stringify(lasHeader.scale));
    metadataMap.set('las_offset', JSON.stringify(lasHeader.offset));
    if (lasHeader.maxs !== undefined) {
        metadataMap.set('las_maxs', JSON.stringify(lasHeader.maxs));
    }
    if (lasHeader.mins !== undefined) {
        metadataMap.set('las_mins', JSON.stringify(lasHeader.mins));
    }
    metadataMap.set('las_totalToRead', lasHeader.totalToRead.toString(10));
    metadataMap.set('las_pointsFortotalReadmatId', lasHeader.totalRead.toString(10));
    if (lasHeader.versionAsString !== undefined) {
        metadataMap.set('las_versionAsString', lasHeader.versionAsString);
    }
    if (lasHeader.isCompressed !== undefined) {
        metadataMap.set('las_isCompressed', lasHeader.isCompressed.toString());
    }
    return metadataMap;
}
exports.makeMetadataFromLasHeader = makeMetadataFromLasHeader;
