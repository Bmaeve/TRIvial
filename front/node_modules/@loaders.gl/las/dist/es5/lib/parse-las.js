"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseLAS;
exports.parseLASChunked = parseLASChunked;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _schema = require("@loaders.gl/schema");
var _laslazDecoder = require("./laslaz-decoder");
var _getLasSchema = require("./get-las-schema");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function parseLAS(arrayBuffer, options) {
  return parseLASMesh(arrayBuffer, options);
}

function parseLASMesh(arrayBuffer) {
  var _options$las;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var pointIndex = 0;
  var positions;
  var colors;
  var intensities;
  var classifications;
  var originalHeader;
  var lasMesh = {
    loader: 'las',
    loaderData: {},
    schema: new _schema.Schema([]),
    header: {
      vertexCount: 0,
      boundingBox: [[0, 0, 0], [0, 0, 0]]
    },
    attributes: {},
    topology: 'point-list',
    mode: 0
  };

  parseLASChunked(arrayBuffer, (_options$las = options.las) === null || _options$las === void 0 ? void 0 : _options$las.skip, function () {
    var _options$las3, _options$onProgress;
    var decoder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var lasHeader = arguments.length > 1 ? arguments[1] : undefined;
    if (!originalHeader) {
      var _options$las2;
      originalHeader = lasHeader;
      var total = lasHeader.totalToRead;
      var PositionsType = (_options$las2 = options.las) !== null && _options$las2 !== void 0 && _options$las2.fp64 ? Float64Array : Float32Array;
      positions = new PositionsType(total * 3);
      colors = lasHeader.pointsFormatId >= 2 ? new Uint8Array(total * 4) : null;
      intensities = new Uint16Array(total);
      classifications = new Uint8Array(total);
      lasMesh.loaderData = lasHeader;
      lasMesh.attributes = {
        POSITION: {
          value: positions,
          size: 3
        },
        intensity: {
          value: intensities,
          size: 1
        },
        classification: {
          value: classifications,
          size: 1
        }
      };
      if (colors) {
        lasMesh.attributes.COLOR_0 = {
          value: colors,
          size: 4
        };
      }
    }
    var batchSize = decoder.pointsCount;
    var _lasHeader$scale = (0, _slicedToArray2.default)(lasHeader.scale, 3),
      scaleX = _lasHeader$scale[0],
      scaleY = _lasHeader$scale[1],
      scaleZ = _lasHeader$scale[2],
      _lasHeader$offset = (0, _slicedToArray2.default)(lasHeader.offset, 3),
      offsetX = _lasHeader$offset[0],
      offsetY = _lasHeader$offset[1],
      offsetZ = _lasHeader$offset[2];
    var twoByteColor = detectTwoByteColors(decoder, batchSize, (_options$las3 = options.las) === null || _options$las3 === void 0 ? void 0 : _options$las3.colorDepth);
    for (var i = 0; i < batchSize; i++) {
      var _decoder$getPoint = decoder.getPoint(i),
        position = _decoder$getPoint.position,
        color = _decoder$getPoint.color,
        intensity = _decoder$getPoint.intensity,
        classification = _decoder$getPoint.classification;
      positions[pointIndex * 3] = position[0] * scaleX + offsetX;
      positions[pointIndex * 3 + 1] = position[1] * scaleY + offsetY;
      positions[pointIndex * 3 + 2] = position[2] * scaleZ + offsetZ;
      if (color && colors) {
        if (twoByteColor) {
          colors[pointIndex * 4] = color[0] / 256;
          colors[pointIndex * 4 + 1] = color[1] / 256;
          colors[pointIndex * 4 + 2] = color[2] / 256;
        } else {
          colors[pointIndex * 4] = color[0];
          colors[pointIndex * 4 + 1] = color[1];
          colors[pointIndex * 4 + 2] = color[2];
        }
        colors[pointIndex * 4 + 3] = 255;
      }
      intensities[pointIndex] = intensity;
      classifications[pointIndex] = classification;
      pointIndex++;
    }
    var meshBatch = _objectSpread(_objectSpread({}, lasMesh), {}, {
      header: {
        vertexCount: lasHeader.totalRead
      },
      progress: lasHeader.totalRead / lasHeader.totalToRead
    });
    options === null || options === void 0 ? void 0 : (_options$onProgress = options.onProgress) === null || _options$onProgress === void 0 ? void 0 : _options$onProgress.call(options, meshBatch);
  });

  lasMesh.header = {
    vertexCount: originalHeader.totalToRead,
    boundingBox: (0, _schema.getMeshBoundingBox)((lasMesh === null || lasMesh === void 0 ? void 0 : lasMesh.attributes) || {})
  };
  if (lasMesh) {
    lasMesh.schema = (0, _getLasSchema.getLASSchema)(lasMesh.loaderData, lasMesh.attributes);
  }
  return lasMesh;
}

function parseLASChunked(rawData, skip) {
  var onParseData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var dataHandler = new _laslazDecoder.LASFile(rawData);
  try {
    dataHandler.open();
    var header = dataHandler.getHeader();
    var Unpacker = dataHandler.getUnpacker();
    var totalToRead = Math.ceil(header.pointsCount / Math.max(1, skip));
    header.totalToRead = totalToRead;
    var totalRead = 0;

    while (true) {
      var chunk = dataHandler.readData(1000 * 100, 0, skip);
      totalRead += chunk.count;
      header.totalRead = totalRead;
      header.versionAsString = chunk.versionAsString;
      header.isCompressed = chunk.isCompressed;
      var unpacker = new Unpacker(chunk.buffer, chunk.count, header);

      onParseData(unpacker, header);
      if (!chunk.hasMoreData || totalRead >= totalToRead) {
        break;
      }
    }
  } catch (e) {
    throw e;
  } finally {
    dataHandler.close();
  }
}

function detectTwoByteColors() {
  var decoder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var batchSize = arguments.length > 1 ? arguments[1] : undefined;
  var colorDepth = arguments.length > 2 ? arguments[2] : undefined;
  var twoByteColor = false;
  switch (colorDepth) {
    case 8:
      twoByteColor = false;
      break;
    case 16:
      twoByteColor = true;
      break;
    case 'auto':
      if (decoder.getPoint(0).color) {
        for (var i = 0; i < batchSize; i++) {
          var _decoder$getPoint2 = decoder.getPoint(i),
            color = _decoder$getPoint2.color;
          if (color[0] > 255 || color[1] > 255 || color[2] > 255) {
            twoByteColor = true;
          }
        }
      }
      break;
    default:
      console.warn('las: illegal value for options.las.colorDepth');
      break;
  }
  return twoByteColor;
}
//# sourceMappingURL=parse-las.js.map